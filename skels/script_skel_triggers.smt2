(set-option :auto-config false)
(declare-const GEN1 Int)
(declare-const GEN2 Int)
(declare-const GEN3 Real)
(declare-const GEN4 Real)
(declare-const BAV5 Bool)
(declare-const BAV6 Bool)
(declare-const BAV7 Bool)
(declare-const BAV8 Bool)
(declare-const BAV9 Bool)
(declare-const BAV10 Bool)
(declare-const BAV11 Bool)
(declare-const BAV12 Bool)
(declare-const BAV13 Bool)
(declare-const BAV14 Bool)
(declare-const BAV15 Bool)
(declare-const BAV16 Bool)
(declare-const BAV17 Bool)
(declare-const BAV18 Bool)
(declare-const BAV19 Bool)
(declare-const BAV20 Bool)
(declare-const BAV21 Bool)
(declare-const BAV22 Bool)
(declare-const BAV23 Bool)
(declare-const BAV24 Bool)
(declare-const BAV25 Bool)
(declare-const BAV26 Bool)
(declare-const BAV27 Bool)
(declare-const BAV28 Bool)
(declare-const BAV29 Bool)
(declare-const BAV30 Bool)
(declare-const BAV31 Bool)
(declare-const BAV32 Bool)
(declare-const BAV33 Bool)
(declare-const BAV34 Bool)
(declare-const BAV35 Bool)
(declare-const BAV36 Bool)
(declare-const BAV37 Bool)
(declare-const BAV38 Bool)
(declare-const BAV39 Bool)
(set-option :smt.mbqi false)
(set-option :smt.qi.eager-threshold 100)
(set-option :type-check true)
(declare-sort |T@U| 0)
(declare-sort |T@T| 0)
(declare-fun int_div (Int Int) Int)
(declare-fun int_mod (Int Int) Int)
(declare-fun UOrdering2 (|T@U| |T@U|) Bool)
(declare-fun UOrdering3 (|T@T| |T@U| |T@U|) Bool)
(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-fun Ctor (T@T) Int)
(declare-fun intType () T@T)
(declare-fun boolType () T@T)
(declare-fun int_2_U (Int) T@U)
(declare-fun U_2_int (T@U) Int)
(declare-fun type (T@U) T@T)
(declare-fun bool_2_U (Bool) T@U)
(declare-fun U_2_bool (T@U) Bool)
(declare-fun HeapTypeType () T@T)
(declare-fun refType () T@T)
(declare-fun vals1 (T@U T@U) T@U)
(declare-fun vals3 (T@U T@U) T@U)
(declare-fun vals2 (T@U T@U) T@U)
(declare-fun trigger2 (T@U) Bool)
(declare-fun trigger1 (T@U) Bool)
(declare-fun heap_trigger (T@U) Bool)
(declare-fun this@@2 () T@U)
(declare-fun Heap@@2 () T@U)
(declare-fun %lbl%+167 () Bool)
(declare-fun %lbl%@242 () Bool)
(declare-fun %lbl%+224 () Bool)
(assert (and (= (Ctor HeapTypeType) GEN1) (= (Ctor refType) GEN2) (forall ((arg0@@3 T@U)(arg1 T@U)) (! (= (type (vals1 arg0@@3 arg1)) refType) :qid |funType:vals1| :pattern ((vals1 arg0@@3 arg1)))) (forall ((arg0@@4 T@U)(arg1@@0 T@U)) (! (= (type (vals3 arg0@@4 arg1@@0)) refType) :qid |funType:vals3| :pattern ((vals3 arg0@@4 arg1@@0))))))
(assert (forall ((Heap T@U)(this T@U)) (! (=> (and (= (type Heap) HeapTypeType) (= (type this) refType)) (= (vals1 Heap this) (vals3 Heap this))) :qid |triggers.13:15| :skolemid |0| :pattern ((vals1 Heap this)))))
(assert (forall ((arg0@@5 T@U)(arg1@@1 T@U)) (! (= (type (vals2 arg0@@5 arg1@@1)) refType) :qid |funType:vals2| :pattern ((vals2 arg0@@5 arg1@@1)))))
(assert (forall ((Heap@@0 T@U)(this@@0 T@U)) (! (=> (and (= (type Heap@@0) HeapTypeType) (= (type this@@0) refType)) (trigger2 this@@0)) :qid |triggers.15:15| :skolemid |1| :pattern ((vals2 Heap@@0 this@@0)))))
(assert (forall ((Heap@@1 T@U)(this@@1 T@U)) (! (=> (and (= (type Heap@@1) HeapTypeType) (= (type this@@1) refType)) (= (vals1 Heap@@1 this@@1) (vals2 Heap@@1 this@@1))) :qid |triggers.18:15| :skolemid |2| :pattern ((vals1 Heap@@1 this@@1)) :pattern ((trigger1 this@@1) (heap_trigger Heap@@1) (trigger2 this@@1)))))
(assert (and (= (type this@@2) refType) (= (type Heap@@2) HeapTypeType)))
(push)
(assert (not (=> (! (and %lbl%+224 true) :lblpos GEN4) (=> (! (and %lbl%+167 true) :lblpos GEN3) (=> (and (trigger1 this@@2) (heap_trigger Heap@@2)) (and (! (or %lbl%@242 (= (vals2 Heap@@2 this@@2) (vals3 Heap@@2 this@@2))) :lblneg @242) (=> (= (vals2 Heap@@2 this@@2) (vals3 Heap@@2 this@@2)) true)))))))
(assert (= BAV5 (and (tickleBool true) (tickleBool false))))
(assert (= BAV6 (and (= (Ctor HeapTypeType) GEN1) (= (Ctor refType) GEN2) (forall ((arg0@@3 T@U)(arg1 T@U)) (! (= (type (vals1 arg0@@3 arg1)) refType) :qid |funType:vals1| :pattern ((vals1 arg0@@3 arg1)))) (forall ((arg0@@4 T@U)(arg1@@0 T@U)) (! (= (type (vals3 arg0@@4 arg1@@0)) refType) :qid |funType:vals3| :pattern ((vals3 arg0@@4 arg1@@0)))))))
(assert (= BAV7 (= (Ctor HeapTypeType) GEN1)))
(assert (= BAV8 (= (Ctor refType) GEN2)))
(assert (= BAV9 (forall ((arg0@@3 T@U)(arg1 T@U)) (= (type (vals1 arg0@@3 arg1)) refType))))
(assert (= BAV10 (forall ((arg0@@4 T@U)(arg1@@0 T@U)) (= (type (vals3 arg0@@4 arg1@@0)) refType))))
(assert (= BAV11 (forall ((Heap T@U)(this T@U)) (=> (and (= (type Heap) HeapTypeType) (= (type this) refType)) (= (vals1 Heap this) (vals3 Heap this))))))
(assert (= BAV12 (forall ((Heap T@U)(this T@U)) (and (= (type Heap) HeapTypeType) (= (type this) refType)))))
(assert (= BAV13 (forall ((Heap T@U)(this T@U)) (= (type Heap) HeapTypeType))))
(assert (= BAV14 (forall ((Heap T@U)(this T@U)) (= (type this) refType))))
(assert (= BAV15 (forall ((Heap T@U)(this T@U)) (= (vals1 Heap this) (vals3 Heap this)))))
(assert (= BAV16 (forall ((arg0@@5 T@U)(arg1@@1 T@U)) (= (type (vals2 arg0@@5 arg1@@1)) refType))))
(assert (= BAV17 (forall ((Heap@@0 T@U)(this@@0 T@U)) (=> (and (= (type Heap@@0) HeapTypeType) (= (type this@@0) refType)) (trigger2 this@@0)))))
(assert (= BAV18 (forall ((Heap@@0 T@U)(this@@0 T@U)) (and (= (type Heap@@0) HeapTypeType) (= (type this@@0) refType)))))
(assert (= BAV19 (forall ((Heap@@0 T@U)(this@@0 T@U)) (= (type Heap@@0) HeapTypeType))))
(assert (= BAV20 (forall ((Heap@@0 T@U)(this@@0 T@U)) (= (type this@@0) refType))))
(assert (= BAV21 (forall ((Heap@@1 T@U)(this@@1 T@U)) (=> (and (= (type Heap@@1) HeapTypeType) (= (type this@@1) refType)) (= (vals1 Heap@@1 this@@1) (vals2 Heap@@1 this@@1))))))
(assert (= BAV22 (forall ((Heap@@1 T@U)(this@@1 T@U)) (and (= (type Heap@@1) HeapTypeType) (= (type this@@1) refType)))))
(assert (= BAV23 (forall ((Heap@@1 T@U)(this@@1 T@U)) (= (type Heap@@1) HeapTypeType))))
(assert (= BAV24 (forall ((Heap@@1 T@U)(this@@1 T@U)) (= (type this@@1) refType))))
(assert (= BAV25 (forall ((Heap@@1 T@U)(this@@1 T@U)) (= (vals1 Heap@@1 this@@1) (vals2 Heap@@1 this@@1)))))
(assert (= BAV26 (and (= (type this@@2) refType) (= (type Heap@@2) HeapTypeType))))
(assert (= BAV27 (= (type this@@2) refType)))
(assert (= BAV28 (= (type Heap@@2) HeapTypeType)))
(assert (= BAV29 (=> (! (and %lbl%+224 true) :lblpos GEN4) (=> (! (and %lbl%+167 true) :lblpos GEN3) (=> (and (trigger1 this@@2) (heap_trigger Heap@@2)) (and (! (or %lbl%@242 (= (vals2 Heap@@2 this@@2) (vals3 Heap@@2 this@@2))) :lblneg @242) (=> (= (vals2 Heap@@2 this@@2) (vals3 Heap@@2 this@@2)) true)))))))
(assert (= BAV30 (and %lbl%+224 true)))
(assert (= BAV31 (=> (! (and %lbl%+167 true) :lblpos GEN3) (=> (and (trigger1 this@@2) (heap_trigger Heap@@2)) (and (! (or %lbl%@242 (= (vals2 Heap@@2 this@@2) (vals3 Heap@@2 this@@2))) :lblneg @242) (=> (= (vals2 Heap@@2 this@@2) (vals3 Heap@@2 this@@2)) true))))))
(assert (= BAV32 (and %lbl%+167 true)))
(assert (= BAV33 (=> (and (trigger1 this@@2) (heap_trigger Heap@@2)) (and (! (or %lbl%@242 (= (vals2 Heap@@2 this@@2) (vals3 Heap@@2 this@@2))) :lblneg @242) (=> (= (vals2 Heap@@2 this@@2) (vals3 Heap@@2 this@@2)) true)))))
(assert (= BAV34 (and (trigger1 this@@2) (heap_trigger Heap@@2))))
(assert (= BAV35 (and (! (or %lbl%@242 (= (vals2 Heap@@2 this@@2) (vals3 Heap@@2 this@@2))) :lblneg @242) (=> (= (vals2 Heap@@2 this@@2) (vals3 Heap@@2 this@@2)) true))))
(assert (= BAV36 (or %lbl%@242 (= (vals2 Heap@@2 this@@2) (vals3 Heap@@2 this@@2)))))
(assert (= BAV37 (= (vals2 Heap@@2 this@@2) (vals3 Heap@@2 this@@2))))
(assert (= BAV38 (=> (= (vals2 Heap@@2 this@@2) (vals3 Heap@@2 this@@2)) true)))
(assert (= BAV39 (= (vals2 Heap@@2 this@@2) (vals3 Heap@@2 this@@2))))
(check-sat)
(get-model)