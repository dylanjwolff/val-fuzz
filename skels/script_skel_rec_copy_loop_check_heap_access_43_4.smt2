(set-option :print-success false)
(set-logic ALL)
(declare-const BAV1 Bool)
(declare-const BAV2 Bool)
(declare-const BAV3 Bool)
(declare-const BAV4 Bool)
(declare-const BAV5 Bool)
(declare-const BAV6 Bool)
(declare-const BAV7 Bool)
(declare-const BAV8 Bool)
(declare-const BAV9 Bool)
(declare-const BAV10 Bool)
(declare-const BAV11 Bool)
(declare-const BAV12 Bool)
(declare-const BAV13 Bool)
(declare-const BAV14 Bool)
(declare-const BAV15 Bool)
(declare-const BAV16 Bool)
(declare-const BAV17 Bool)
(declare-const BAV18 Bool)
(declare-const BAV19 Bool)
(declare-const BAV20 Bool)
(declare-const BAV21 Bool)
(declare-const BAV22 Bool)
(declare-const BAV23 Bool)
(declare-const BAV24 Bool)
(declare-const BAV25 Bool)
(declare-const BAV26 Bool)
(declare-const BAV27 Bool)
(declare-const BAV28 Bool)
(declare-const BAV29 Bool)
(declare-const BAV30 Bool)
(declare-const BAV31 Bool)
(declare-const BAV32 Bool)
(declare-const BAV33 Bool)
(declare-const BAV34 Bool)
(declare-const BAV35 Bool)
(declare-const BAV36 Bool)
(declare-const BAV37 Bool)
(declare-const BAV38 Bool)
(declare-const BAV39 Bool)
(declare-const BAV40 Bool)
(declare-const BAV41 Bool)
(declare-const BAV42 Bool)
(declare-const BAV43 Bool)
(declare-const BAV44 Bool)
(declare-sort Loc 0)
(define-sort SetLoc () (Set Loc))
(define-sort SetInt () (Set Int))
(declare-sort FldLoc 0)
(declare-sort FldInt 0)
(declare-fun null$0 () Loc)
(declare-fun read$0 (FldLoc Loc) Loc)
(declare-fun Btwn$0 (FldLoc Loc Loc Loc) Bool)
(declare-fun Alloc$0 () SetLoc)
(declare-fun Alloc_2$0 () SetLoc)
(declare-fun FP$0 () SetLoc)
(declare-fun FP_3$0 () SetLoc)
(declare-fun FP_Caller$0 () SetLoc)
(declare-fun FP_Caller_2$0 () SetLoc)
(declare-fun cp$0 () Loc)
(declare-fun cp_1$0 () Loc)
(declare-fun curr$0 () Loc)
(declare-fun lseg_domain$0 (FldLoc Loc Loc) SetLoc)
(declare-fun lseg_struct$0 (SetLoc FldLoc Loc Loc) Bool)
(declare-fun next$0 () FldLoc)
(declare-fun old_cp_2$0 () Loc)
(declare-fun sk_?X_36$0 () SetLoc)
(declare-fun sk_?X_37$0 () SetLoc)
(declare-fun sk_?X_38$0 () SetLoc)
(declare-fun tmp_1$0 () Loc)
(assert (! (forall ((?y Loc)) (or (not (Btwn$0 next$0 null$0 ?y ?y)) (= null$0 ?y) (Btwn$0 next$0 null$0 (read$0 next$0 null$0) ?y))) :named btwn_reach_6))
(assert (! (forall ((?y Loc)) (or (not (= (read$0 next$0 null$0) null$0)) (not (Btwn$0 next$0 null$0 ?y ?y)) (= null$0 ?y))) :named btwn_cycl_6))
(assert (! (Btwn$0 next$0 null$0 (read$0 next$0 null$0) (read$0 next$0 null$0)) :named btwn_step_6))
(assert (! (= (read$0 next$0 null$0) null$0) :named read_null_6))
(assert (! (forall ((l1 Loc)) (or (and (Btwn$0 next$0 curr$0 l1 null$0) (member l1 (lseg_domain$0 next$0 curr$0 null$0)) (not (= l1 null$0))) (and (or (= l1 null$0) (not (Btwn$0 next$0 curr$0 l1 null$0))) (not (member l1 (lseg_domain$0 next$0 curr$0 null$0)))))) :named lseg_footprint_14))
(assert (! (not (member tmp_1$0 Alloc$0)) :named new_42_10))
(assert (! (not (member null$0 Alloc$0)) :named initial_footprint_of_rec_copy_loop_34_11_4))
(assert (! (not (= curr$0 null$0)) :named if_else_37_6))
(assert (! (lseg_struct$0 sk_?X_37$0 next$0 curr$0 null$0) :named precondition_of_rec_copy_loop_34_11_16))
(assert (! (= sk_?X_38$0 (lseg_domain$0 next$0 cp$0 null$0)) :named precondition_of_rec_copy_loop_34_11_17))
(assert (! (= sk_?X_36$0 FP$0) :named precondition_of_rec_copy_loop_34_11_18))
(assert (! (= (as emptyset SetLoc) (intersection sk_?X_38$0 sk_?X_37$0)) :named precondition_of_rec_copy_loop_34_11_19))
(assert (! (= old_cp_2$0 cp$0) :named assign_41_4))
(assert (! (= FP_Caller_2$0 (setminus FP_Caller$0 FP$0)) :named assign_37_2_2))
(assert (! (= Alloc_2$0 (union Alloc$0 (singleton tmp_1$0))) :named assign_42_10))
(assert (! (or (Btwn$0 next$0 cp$0 null$0 null$0) (not (lseg_struct$0 sk_?X_38$0 next$0 cp$0 null$0))) :named unnamed_22))
(assert (! (forall ((l1 Loc)) (or (and (Btwn$0 next$0 cp$0 l1 null$0) (member l1 (lseg_domain$0 next$0 cp$0 null$0)) (not (= l1 null$0))) (and (or (= l1 null$0) (not (Btwn$0 next$0 cp$0 l1 null$0))) (not (member l1 (lseg_domain$0 next$0 cp$0 null$0)))))) :named lseg_footprint_15))
(assert (! (not (member cp_1$0 FP_3$0)) :named check_heap_access_43_4))
(assert (! (not (= tmp_1$0 null$0)) :named new_42_10_1))
(assert (! (lseg_struct$0 sk_?X_38$0 next$0 cp$0 null$0) :named precondition_of_rec_copy_loop_34_11_20))
(assert (! (= FP_Caller$0 (union FP$0 FP_Caller$0)) :named precondition_of_rec_copy_loop_34_11_21))
(assert (! (= sk_?X_37$0 (lseg_domain$0 next$0 curr$0 null$0)) :named precondition_of_rec_copy_loop_34_11_22))
(assert (! (= sk_?X_36$0 (union sk_?X_37$0 sk_?X_38$0)) :named precondition_of_rec_copy_loop_34_11_23))
(assert (! (= Alloc$0 (union FP_Caller$0 Alloc$0)) :named initial_footprint_of_rec_copy_loop_34_11_5))
(assert (! (= cp_1$0 tmp_1$0) :named assign_42_4))
(assert (! (= FP_3$0 (union FP$0 (singleton tmp_1$0))) :named assign_42_10_1))
(assert (! (or (Btwn$0 next$0 curr$0 null$0 null$0) (not (lseg_struct$0 sk_?X_37$0 next$0 curr$0 null$0))) :named unnamed_23))
(assert (! (forall ((?x Loc)) (Btwn$0 next$0 ?x ?x ?x)) :named btwn_refl_6))
(assert (! (forall ((?x Loc)(?y Loc)) (or (not (Btwn$0 next$0 ?x ?y ?x)) (= ?x ?y))) :named btwn_sndw_6))
(assert (! (forall ((?x Loc)(?y Loc)(?z Loc)) (or (not (Btwn$0 next$0 ?x ?y ?y)) (not (Btwn$0 next$0 ?x ?z ?z)) (Btwn$0 next$0 ?x ?y ?z) (Btwn$0 next$0 ?x ?z ?y))) :named btwn_ord1_6))
(assert (! (forall ((?x Loc)(?y Loc)(?z Loc)) (or (not (Btwn$0 next$0 ?x ?y ?z)) (and (Btwn$0 next$0 ?x ?y ?y) (Btwn$0 next$0 ?y ?z ?z)))) :named btwn_ord2_6))
(assert (! (forall ((?x Loc)(?y Loc)(?z Loc)) (or (not (Btwn$0 next$0 ?x ?y ?y)) (not (Btwn$0 next$0 ?y ?z ?z)) (Btwn$0 next$0 ?x ?z ?z))) :named btwn_trn1_6))
(assert (! (forall ((?u Loc)(?x Loc)(?y Loc)(?z Loc)) (or (not (Btwn$0 next$0 ?x ?y ?z)) (not (Btwn$0 next$0 ?y ?u ?z)) (and (Btwn$0 next$0 ?x ?y ?u) (Btwn$0 next$0 ?x ?u ?z)))) :named btwn_trn2_6))
(assert (! (forall ((?u Loc)(?x Loc)(?y Loc)(?z Loc)) (or (not (Btwn$0 next$0 ?x ?y ?z)) (not (Btwn$0 next$0 ?x ?u ?y)) (and (Btwn$0 next$0 ?x ?u ?z) (Btwn$0 next$0 ?u ?y ?z)))) :named btwn_trn3_6))
(assert (= BAV1 (forall ((?y Loc)) (or (not (Btwn$0 next$0 null$0 ?y ?y)) (= null$0 ?y) (Btwn$0 next$0 null$0 (read$0 next$0 null$0) ?y)))))
(assert (= BAV2 (forall ((?y Loc)) (= null$0 ?y))))
(assert (= BAV3 (forall ((?y Loc)) (or (not (= (read$0 next$0 null$0) null$0)) (not (Btwn$0 next$0 null$0 ?y ?y)) (= null$0 ?y)))))
(assert (= BAV4 (forall ((?y Loc)) (= (read$0 next$0 null$0) null$0))))
(assert (= BAV5 (forall ((?y Loc)) (= null$0 ?y))))
(assert (= BAV6 (= (read$0 next$0 null$0) null$0)))
(assert (= BAV7 (forall ((l1 Loc)) (or (and (Btwn$0 next$0 curr$0 l1 null$0) (member l1 (lseg_domain$0 next$0 curr$0 null$0)) (not (= l1 null$0))) (and (or (= l1 null$0) (not (Btwn$0 next$0 curr$0 l1 null$0))) (not (member l1 (lseg_domain$0 next$0 curr$0 null$0))))))))
(assert (= BAV8 (forall ((l1 Loc)) (and (Btwn$0 next$0 curr$0 l1 null$0) (member l1 (lseg_domain$0 next$0 curr$0 null$0)) (not (= l1 null$0))))))
(assert (= BAV9 (forall ((l1 Loc)) (= l1 null$0))))
(assert (= BAV10 (forall ((l1 Loc)) (and (or (= l1 null$0) (not (Btwn$0 next$0 curr$0 l1 null$0))) (not (member l1 (lseg_domain$0 next$0 curr$0 null$0)))))))
(assert (= BAV11 (forall ((l1 Loc)) (or (= l1 null$0) (not (Btwn$0 next$0 curr$0 l1 null$0))))))
(assert (= BAV12 (forall ((l1 Loc)) (= l1 null$0))))
(assert (= BAV13 (= curr$0 null$0)))
(assert (= BAV14 (= sk_?X_38$0 (lseg_domain$0 next$0 cp$0 null$0))))
(assert (= BAV15 (= sk_?X_36$0 FP$0)))
(assert (= BAV16 (= (as emptyset SetLoc) (intersection sk_?X_38$0 sk_?X_37$0))))
(assert (= BAV17 (= old_cp_2$0 cp$0)))
(assert (= BAV18 (= FP_Caller_2$0 (setminus FP_Caller$0 FP$0))))
(assert (= BAV19 (= Alloc_2$0 (union Alloc$0 (singleton tmp_1$0)))))
(assert (= BAV20 (or (Btwn$0 next$0 cp$0 null$0 null$0) (not (lseg_struct$0 sk_?X_38$0 next$0 cp$0 null$0)))))
(assert (= BAV21 (forall ((l1 Loc)) (or (and (Btwn$0 next$0 cp$0 l1 null$0) (member l1 (lseg_domain$0 next$0 cp$0 null$0)) (not (= l1 null$0))) (and (or (= l1 null$0) (not (Btwn$0 next$0 cp$0 l1 null$0))) (not (member l1 (lseg_domain$0 next$0 cp$0 null$0))))))))
(assert (= BAV22 (forall ((l1 Loc)) (and (Btwn$0 next$0 cp$0 l1 null$0) (member l1 (lseg_domain$0 next$0 cp$0 null$0)) (not (= l1 null$0))))))
(assert (= BAV23 (forall ((l1 Loc)) (= l1 null$0))))
(assert (= BAV24 (forall ((l1 Loc)) (and (or (= l1 null$0) (not (Btwn$0 next$0 cp$0 l1 null$0))) (not (member l1 (lseg_domain$0 next$0 cp$0 null$0)))))))
(assert (= BAV25 (forall ((l1 Loc)) (or (= l1 null$0) (not (Btwn$0 next$0 cp$0 l1 null$0))))))
(assert (= BAV26 (forall ((l1 Loc)) (= l1 null$0))))
(assert (= BAV27 (= tmp_1$0 null$0)))
(assert (= BAV28 (= FP_Caller$0 (union FP$0 FP_Caller$0))))
(assert (= BAV29 (= sk_?X_37$0 (lseg_domain$0 next$0 curr$0 null$0))))
(assert (= BAV30 (= sk_?X_36$0 (union sk_?X_37$0 sk_?X_38$0))))
(assert (= BAV31 (= Alloc$0 (union FP_Caller$0 Alloc$0))))
(assert (= BAV32 (= cp_1$0 tmp_1$0)))
(assert (= BAV33 (= FP_3$0 (union FP$0 (singleton tmp_1$0)))))
(assert (= BAV34 (or (Btwn$0 next$0 curr$0 null$0 null$0) (not (lseg_struct$0 sk_?X_37$0 next$0 curr$0 null$0)))))
(assert (= BAV35 (forall ((?x Loc)(?y Loc)) (or (not (Btwn$0 next$0 ?x ?y ?x)) (= ?x ?y)))))
(assert (= BAV36 (forall ((?x Loc)(?y Loc)) (= ?x ?y))))
(assert (= BAV37 (forall ((?x Loc)(?y Loc)(?z Loc)) (or (not (Btwn$0 next$0 ?x ?y ?y)) (not (Btwn$0 next$0 ?x ?z ?z)) (Btwn$0 next$0 ?x ?y ?z) (Btwn$0 next$0 ?x ?z ?y)))))
(assert (= BAV38 (forall ((?x Loc)(?y Loc)(?z Loc)) (or (not (Btwn$0 next$0 ?x ?y ?z)) (and (Btwn$0 next$0 ?x ?y ?y) (Btwn$0 next$0 ?y ?z ?z))))))
(assert (= BAV39 (forall ((?x Loc)(?y Loc)(?z Loc)) (and (Btwn$0 next$0 ?x ?y ?y) (Btwn$0 next$0 ?y ?z ?z)))))
(assert (= BAV40 (forall ((?x Loc)(?y Loc)(?z Loc)) (or (not (Btwn$0 next$0 ?x ?y ?y)) (not (Btwn$0 next$0 ?y ?z ?z)) (Btwn$0 next$0 ?x ?z ?z)))))
(assert (= BAV41 (forall ((?u Loc)(?x Loc)(?y Loc)(?z Loc)) (or (not (Btwn$0 next$0 ?x ?y ?z)) (not (Btwn$0 next$0 ?y ?u ?z)) (and (Btwn$0 next$0 ?x ?y ?u) (Btwn$0 next$0 ?x ?u ?z))))))
(assert (= BAV42 (forall ((?u Loc)(?x Loc)(?y Loc)(?z Loc)) (and (Btwn$0 next$0 ?x ?y ?u) (Btwn$0 next$0 ?x ?u ?z)))))
(assert (= BAV43 (forall ((?u Loc)(?x Loc)(?y Loc)(?z Loc)) (or (not (Btwn$0 next$0 ?x ?y ?z)) (not (Btwn$0 next$0 ?x ?u ?y)) (and (Btwn$0 next$0 ?x ?u ?z) (Btwn$0 next$0 ?u ?y ?z))))))
(assert (= BAV44 (forall ((?u Loc)(?x Loc)(?y Loc)(?z Loc)) (and (Btwn$0 next$0 ?x ?u ?z) (Btwn$0 next$0 ?u ?y ?z)))))
(check-sat)
(get-model)
(exit)